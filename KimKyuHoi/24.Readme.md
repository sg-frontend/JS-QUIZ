## 정답 해설

### 함수 분석하기

```js
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```

스크립트에서 객체의 키는 자동으로 문자열로 변환되기 때문에 아래와 같은 현상이 발생함

**실제 저장된다면**

```js
const obj = { 1: 'a', 2: 'b', 3: 'c' };
```

### 🔧 자바스크립트 엔진 관점: 객체 키는 왜 문자열로 변할까?

**📌 1. JS 엔진이 객체의 키를 처리하는 방식**

자바스크립트에서 객체는 해시 테이블(Hash Table) 형태로 구현되어 있음.
이 해시 테이블은 내부적으로 문자열 키(string) 기반으로 작동함.

```js
const obj = { 1: 'a' };
```

이 코드를 JS 엔진이 처리할 때:

1. 1이라는 숫자 리터럴 키가 등장
2. JS 엔진은 "객체의 키는 문자열이야"라고 알고 있기 때문에
3. '1'이라는 문자열로 자동 변환해서 저장합니다
4. 결국 내부 구조는: `{ '1': 'a' }`

**⚖️ 비교: Map과 Set은 왜 다르게 작동할까?**

- `Object`: 키가 항상 문자열 또는 심벌로 강제 변환됨
- `Map`: 키가 원시값이나 객체 그대로 유지됨
- `Set`: 값이 그대로 저장되며, 타입까지 구분함

```js
const map = new Map();
map.set(1, 'a');
map.set('1', 'b');
console.log(map); // Map { 1 => 'a', '1' => 'b' }

const set = new Set([1, '1']);
console.log(set); // Set { 1, '1' }
```

📌 → 여기서 JS 엔진은 Map/Set의 키는 타입까지 구분해주도록 설계되어 있기 때문에, '1'과 1을 다른 것으로 인식합니다.
