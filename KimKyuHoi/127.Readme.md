## 구조분해 할당(Destructuring Assignment) ― 핵심부터 예시까지

### 1. 한 줄 정의

> 구조분해 할당은 우변의 값(객체·배열·이터러블)을 패턴으로 “매칭”해 좌변의 변수들에 한꺼번에 할당하는 ES2015 문법입니다.
>
> 즉 “필요한 조각만 골라 담는 문법적 설탕(Syntactic Sugar)”.

---

### 2. 문법 기본

| 구분              | 패턴 예시                                    | 특징 & 자주 쓰는 옵션                                                                                                      |
| ----------------- | -------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| **배열 패턴**     | `const [a, , c = 0, ...rest] = arr;`         | • **위치 기반** 매칭• 값이 없으면 `undefined`• 기본값·나머지(`...rest`)·중첩 가능                                          |
| **객체 패턴**     | `const { key: alias = def, ...rest } = obj;` | • **키 이름** 기반 매칭• `:` 로 **변수명 변경**• 기본값·나머지 패턴 가능• **계산된 키**: `const { [dynamicKey]: v } = obj` |
| **혼합 & 중첩**   | `const [ {x}, [y] ] = data`                  | 패턴 안에 또 다른 패턴 사용 가능                                                                                           |
| **함수 매개변수** | `function f({id, page=1}) {}`                | 호출 시 구조분해 + 기본값 처리                                                                                             |
| **할당식**        | `({a} = obj2)` / `([x] = arr2)`              | **이미 선언된 변수**에 다시 대입할 때객체 패턴은 반드시 괄호 `()` 필요(파서가 블록으로 착각 방지)                          |

---

### 3. 평가 순서(알아두면 면접 가산점)

1. **우변** 전체를 먼저 평가해 **객체/배열 참조** 확보
2. **패턴**을 *왼→오*로 해석하며 **“L-value(대입 위치)”** 계산
   - 배열 인덱스면 `obj[index]`, 객체 키면 `obj.key`
3. 각각의 위치에 **값 복사(또는 속성 조회)**
4. 기본값 표현식이 있으면 `=== undefined` 일 때만 평가
5. 최종 **할당식의 결과 값** 은 패턴에 담긴 **마지막 평가 값**(`'💀'` 예시처럼)

> ❗ const로 선언했어도 바인딩 재할당만 막을 뿐, 참조형 내부는 언제든 mutation 가능하다는 점(예시 코드의 핵심 트릭).
