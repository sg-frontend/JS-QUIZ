# 정답 해설

## 함수 분석하기

```js
console.log(Number(2) === Number(2));
console.log(Boolean(false) === Boolean(false));
console.log(Symbol('foo') === Symbol('foo'));
```

### 🔍 Symbol의 주요 특징

| 특징                         | 설명                                                                                     |
| ---------------------------- | ---------------------------------------------------------------------------------------- |
| 유일성                       | `Symbol()`은 절대로 같은 값을 생성하지 않음 (`Symbol('a') !== Symbol('a')`)              |
| 변경 불가능                  | 한 번 생성된 심볼은 수정 불가                                                            |
| 객체 속성 키로 사용 가능     | 객체의 고유한 속성 이름으로 사용 가능 (충돌 방지용)                                      |
| `Symbol()` vs `Symbol.for()` | `Symbol.for('key')`는 글로벌 심볼 레지스트리에 저장되므로 **같은 키면 동일한 심볼 반환** |

### Symbol이 매번 고유한 값을 생헝하는 이유

JavaScript 객체에서 일반적으로 속성 키로는 문자열을 사용함.

```js
const user = {
  name: '규회',
  id: 'kgh123',
};
```

그런데 내가 만든 객체에 외부 라이브러리나 다른 개발자가 만든 코드가 다음과 같이 속성을 추가한다고 해봅시다:

```js
user.id = 'hacker123'; // 기존 속성 덮어쓰기 😱
```

이럴 때 기존 프로퍼티를 덮어쓰는 위험이 생깁니다.

### Symbol이 Memory Heap에 저장되는 이유

> 🔍 Symbol은 primitive이지만, 내부적으로는 "고유 식별자를 관리하는 객체처럼" 작동하기 때문이에요.

**✅ Symbol은 "primitive로 동작하지만", 엔진 내부에서는 객체처럼 관리됩니다.**

- 즉, 사용자 관점에서는 primitive이지만,

- 엔진은 그 고유한 식별성을 유지하기 위해 Heap 같은 메모리 공간에 실제 값을 저장합니다.

```js
const s1 = Symbol('id');
const s2 = Symbol('id');
console.log(s1 === s2); // false → 즉, 내부 식별자가 다름
```

### 결론

| 항목           | 사용자 관점                     | 엔진 내부                                    |
| -------------- | ------------------------------- | -------------------------------------------- |
| `Symbol`       | Primitive (stack 저장처럼 보임) | 내부 고유값을 관리하기 위해 heap에 실제 저장 |
| `Symbol.for()` | 공유 가능한 primitive           | 전역 레지스트리(힙 테이블 형태)에서 관리     |
