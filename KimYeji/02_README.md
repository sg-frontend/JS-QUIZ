## 🔎 문제 코드

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}
```

## ✅ 해설

### 1. var / let 스코프

- `var` 은 **함수 스코프**를 가지기 때문에 해당 함수 안에서 하나의 변수 i를 공유함.
- `let`은 **블록 스코프**를 가지기 때문에 해당 함수 안에서 매 반복마다 새로운 변수 i를 생성함.

### 2. setTimeout의 작동 방식

`setTimeout`은 비동기로 실행되기 때문에 반복문 안에서 콜백이 바로 실행되지 않고 반복문이 끝난 다음 실행됨.

반복문 돌면서 setTimeout 등록 -> 반복문 종료 -> 콜백함수 실행 -> 콜백에서 i 참조

### 3. 실행 결과

```js
// var은 함수 스코프이기 때문에 반복문 종료 후 i 값인 3 출력
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1); // 3 3 3
}

// let은 블록 스코프이기 때문에 선언 시점의 변수 값을 각각 기억하여 사용
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1); // 0 1 2
}
```

## 🧠 관련 개념

### 클로저

함수가 선언될 때의 스코프를 기억하는 기능임. 함수가 실행된 다음에도 클로저는 해당 함수가 선언된 환경을 참조할 수 있음.

### 클로저의 장점

- 데이터 은닉 : 함수 내부의 변수를 외부에서 직접 접근할 수 없음
- 모듈화, 코드 재사용성
- 데이터 캐싱 : 클로저를 통해 계산 값을 저장해두고 반복 계산을 줄일 수 있음
